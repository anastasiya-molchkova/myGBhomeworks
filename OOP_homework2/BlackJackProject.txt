Можно сделать следующие классы:

1) "Карта" - class Card
{
c перечислениями мастей и достоинств карт,
переменными для представления масти и достоинства карты:
private:
	Suits m_suit;
	CardRanks m_rank;
public:
	//конструктор класса Card с инициализацией карт (переменных-членов класса)
	Card(Suits suit = suitsNumber, CardRanks rank = ranksNumber) : m_suit(suit), m_rank(rank)
	{}
и методы:
	//printCard функция возвращает принимаемую как параметр карту в виде строки типа ДостоинствоМасть
	string printCard() const
	{}

	//getCardValue возвращает значение карты (валет, королева или король — это 10, туз — это 11)
	unsigned short getCardValue() const
	{}
};

2) "Колода" - class Deck
{
private:
	//для представления целой колоды карт (52 карты) создаём массив deck (используя std::array) из карт
	std::array <Card, Card::Suits::suitsNumber * Card::CardRanks::ranksNumber> m_deck;
	//в качестве указателя на следующую карту в колоде:
	unsigned short m_cardIndex = 0;
public:
	// конструктор, который не принимает никаких параметров и инициализирует каждый элемент массива m_deck случайной картой  
	Deck()
	{}
	
	//функция выводит все значения (карты) из колоды
	void printDeck() const
	{}

	// открытый метод dealCard(), который будет возвращать константную ссылку на текущую карту
	const Card& dealCard()
	{}
	// открытый метод goToTheNextCard(), который будет увеличивать m_cardIndex
	void goToTheNextCard()
	{}

private:
	//функция выбора случайного числа между двумя заданными значениями
	static unsigned short getRandomNumber(unsigned short min, unsigned short max)
	{}
	//функция принимает две карты по ссылке и меняет местами их значения
	static void swap2Cards(Card& cardA, Card& cardB)
	{}
public:
	//функция для перетасовки колоды карт
	void shuffleDeck()
	{}
};

3) "Игрок" с картами на руках и суммарным количеством очков, 
ещё понадобится отдельно считать количество тузов, 
т.к. нужно считать туз как 1 вместо 11, если сумма больше 21

4) "Пользователь", который должен наследовать от Игрока, а также иметь дополнительные методы типа таких:
// возвращает истину, если игрок хочет сыграть ещё раз и ложь, если не хочет
bool wantsContinue()
{}
//получаем внятный ответ от пользователя, что он хочет - взять карту или остановиться, возвращаем истину, если хочет взять и ложь - если остановиться
bool playerWantsHit()
{}

5) "Игра в БлэкДжэк"
с константной целью по очкам
	static const unsigned short goal = 21;
и лимитом для дилера
	static const unsigned short dealerLimit{ 17 };
а также переменными для игрока и дилера
и переменной для кодирования того, кто победил

ещё нужен метод для печати результата
и какой-то большой метод, который будет кодировать весь ход игры:
	//дилеру в открытую раздаётся первая карта из перемешанной колоды
	//одну карту "раздали", переходим на следующую карту
	//игроку раздаются следующие две карты из колоды
	//две карты "раздали", переходим на следующую карту

	//Ход игрока, пока он не переберёт или пока не решит остановиться
        // если перебрал
		// "К сожалению, ВЫ ПРОИГРАЛИ, ведь у Вас больше 21 очка!"
	// если игрок остановился на сумме меньше 21:
		//Ход дилера, пока не наберёт 17 или выше, он берёт очередную карту из колоды:
        // ходы окончены, разбираемся, кто победил и вызываем метод для печати результата
