#include <stdio.h>
#include <stdlib.h>
#include <locale.h>  // для кириллицы

// НУЖНЫЙ КОД С УРОКОВ:

#define True (1 == 1)
#define False (1 != 1)

typedef int boolean;

// заполняет массив случайными числами
void fillArrayRandom(int* array, int len, const unsigned max)
{
    for (int i = 0; i < len; ++i)
        array[i] = rand() % max;
}

// печатает массив
void printArray(int* array, int len)
{
    for (int i = 0; i < len; ++i)
        printf("%4d ", array[i]);
    printf("\n");
}

// создаёт 2D массив
int** init2DArray(int rows, int cols)
{
    int** array = (int**)calloc(sizeof(int*), rows);
    for (int i = 0; i < rows; ++i)
        *(array + i) = (int*)calloc(sizeof(int), cols);
    return array;
}

// заполняет 2D массив случайными числами
void fill2DarrayRandom(int** array, int rows, int cols, const unsigned max)
{
    for (int i = 0; i < rows; ++i)
        for (int j = 0; j < cols; ++j)
            *(*(array + i) + j) = rand() % max;
}

int get2dInt(int** array, const int row, const int col) 
{
    return *((*(array + row)) + col);

}

void set2dInt(int** array, const int row, const int col, int value) 
{
    *((*(array + row)) + col) = value;
}

// СТЭК

#define T int

typedef struct OneLinkNode 
{
    int data;
    struct OneLinkNode* next;
} OneLinkNode;

typedef struct 
{
    OneLinkNode* head;
    int size;
} OneLinkList;

void initOneLinkList(OneLinkList* lst) 
{
    lst->head = NULL;
    lst->size = 0;
}

void printOneLinkIntNode(OneLinkNode* n) 
{
    if (n == NULL) {
        printf("[]");
        return;
    }
    printf("[%d]", n->data);
}

void printOneLinkIntList(OneLinkList* lst) 
{
    OneLinkNode* current = lst->head;
    if (current == NULL) {
        printOneLinkIntNode(current);
    }
    else {
        do {
            printOneLinkIntNode(current);
            current = current->next;
        } while (current != NULL);
    }
    printf(" Size: %d \n", lst->size);
}

boolean pushOneLinkStack(OneLinkList* stack, T value) {
    OneLinkNode* tmp = (OneLinkNode*)malloc(sizeof(OneLinkNode));
    if (tmp == NULL) {
        printf("Stack overflow \n");
        return false;
    }
    tmp->data = value;
    tmp->next = stack->head;

    stack->head = tmp;
    stack->size++;
    return true;
}

T popOneLinkStack(OneLinkList* stack) {
    if (stack->size == 0) {
        printf("Stack is empty \n");
        return -1;
    }
    OneLinkNode* tmp = stack->head;
    T data = stack->head->data;
    stack->head = stack->head->next;
    free(tmp);
    stack->size--;
    return data;
}

///////////////////// ЗАДАНИЕ 1

// печатает матрицу смежности
void printAdjMatrix(int** array, int nodes)
{
    printf("Матрица смежности: \n   ");
    // печать номеров столбцов
    for (int j = 0; j < nodes; ++j)
        printf("%2d ", j);
    printf("\n");

    for (int i = 0; i < nodes; ++i)
    {
        printf("%2d ", i);   // печать номеров строк
        for (int j = 0; j < nodes; ++j)
            printf("%2d ", *(*(array + i) + j));
        printf("\n");
    }
}

// обход графа в глубину. На входе матрица смежности, количество вершин и стартовая вершина для обхода:
void depthTravers(int** matrix, const int nodes, const int start)
{
    // в стэке будем держать вершины, для которых нужно обойти смежные
    OneLinkList* stack = (OneLinkList*)malloc(sizeof(OneLinkList));
    initOneLinkList(stack);  // изначально стэк пуст

    // также нам понадобится массив посещённых вершин. Там единицей будем помечать посещённые вершины
    int* visited = (int*)calloc(nodes, sizeof(int));  // изначально массив обнулён

    // добавляем начальную вершину в стэк, отмечаем как посещённую и выводим на экран
    pushOneLinkStack(stack, start);
    visited[start] = 1;
    printf("%d ", start);

    int current_node = start;
    while (stack->size != 0)
    {
        current_node = popOneLinkStack(stack);
        for (int next_node = 0; next_node < nodes; ++next_node)
            // если есть путь в соседнюю вершину и она не посещалась
            if ((get2dInt(matrix, current_node, next_node) == 1) && !visited[next_node])
            {
                visited[next_node] = 1;
                printf("%d ", next_node);
                pushOneLinkStack(stack, next_node);
            }
    }
}

// создаёт случайный граф для заданного количества вершин и обходит его в глубину из нескольких вершин
void task1()
{
    printf("1. Обход графа в глубину при помощи стэка.\n\n");

    const int nodes = 10;
    int** graph = init2DArray(nodes, nodes);
    fill2DarrayRandom(graph, nodes, nodes, 2);
    printAdjMatrix(graph, nodes);

    printf("Пути обхода графа из нескольких вершин:\n");
    depthTravers(graph, nodes, 0);
    printf("\n");
    depthTravers(graph, nodes, 3);
    printf("\n");
    depthTravers(graph, nodes, 4);

    printf("\n\n");
}

int main()
{
    setlocale(LC_CTYPE, "rus");  // для кириллицы
    task1();
    return 0;
}