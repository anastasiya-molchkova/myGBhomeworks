#include <stdio.h>
#include <stdlib.h>
#include <locale.h>  // для кириллицы

// НУЖНЫЙ КОД С УРОКОВ:

#define True (1 == 1)
#define False (1 != 1)

typedef int boolean;

// заполняет массив случайными числами
void fillArrayRandom(int* array, int len, const unsigned max)
{
    for (int i = 0; i < len; ++i)
        array[i] = rand() % max;
}

// печатает массив
void printArray(int* array, int len)
{
    for (int i = 0; i < len; ++i)
        printf("%4d ", array[i]);
    printf("\n");
}

// создаёт 2D массив
int** init2DArray(int rows, int cols)
{
    int** array = (int**)calloc(sizeof(int*), rows);
    for (int i = 0; i < rows; ++i)
        *(array + i) = (int*)calloc(sizeof(int), cols);
    return array;
}

// заполняет 2D массив случайными числами
void fill2DarrayRandom(int** array, int rows, int cols, const unsigned max)
{
    for (int i = 0; i < rows; ++i)
        for (int j = 0; j < cols; ++j)
            *(*(array + i) + j) = rand() % max;
}

int get2dInt(int** array, const int row, const int col) 
{
    return *((*(array + row)) + col);

}

void set2dInt(int** array, const int row, const int col, int value) 
{
    *((*(array + row)) + col) = value;
}

// СТЭК

#define T int

typedef struct OneLinkNode 
{
    int data;
    struct OneLinkNode* next;
} OneLinkNode;

typedef struct 
{
    OneLinkNode* head;
    int size;
} OneLinkList;

void initOneLinkList(OneLinkList* lst) 
{
    lst->head = NULL;
    lst->size = 0;
}

void printOneLinkIntNode(OneLinkNode* n) 
{
    if (n == NULL) {
        printf("[]");
        return;
    }
    printf("[%d]", n->data);
}

void printOneLinkIntList(OneLinkList* lst) 
{
    OneLinkNode* current = lst->head;
    if (current == NULL) {
        printOneLinkIntNode(current);
    }
    else {
        do {
            printOneLinkIntNode(current);
            current = current->next;
        } while (current != NULL);
    }
    printf(" Size: %d \n", lst->size);
}

boolean pushOneLinkStack(OneLinkList* stack, T value) {
    OneLinkNode* tmp = (OneLinkNode*)malloc(sizeof(OneLinkNode));
    if (tmp == NULL) {
        printf("Stack overflow \n");
        return false;
    }
    tmp->data = value;
    tmp->next = stack->head;

    stack->head = tmp;
    stack->size++;
    return true;
}

T popOneLinkStack(OneLinkList* stack) {
    if (stack->size == 0) {
        printf("Stack is empty \n");
        return -1;
    }
    OneLinkNode* tmp = stack->head;
    T data = stack->head->data;
    stack->head = stack->head->next;
    free(tmp);
    stack->size--;
    return data;
}

///////////////////// ЗАДАНИЕ 1

// печатает матрицу смежности
void printAdjMatrix(int** array, int nodes)
{
    printf("Матрица смежности: \n   ");
    // печать номеров столбцов
    for (int j = 0; j < nodes; ++j)
        printf("%2d ", j);
    printf("\n");

    for (int i = 0; i < nodes; ++i)
    {
        printf("%2d ", i);   // печать номеров строк
        for (int j = 0; j < nodes; ++j)
            printf("%2d ", *(*(array + i) + j));
        printf("\n");
    }
}

// обход графа в глубину. На входе матрица смежности, количество вершин и стартовая вершина для обхода:
void depthTravers(int** matrix, const int nodes, const int start)
{
    // в стэке будем держать вершины, для которых нужно обойти смежные
    OneLinkList* stack = (OneLinkList*)malloc(sizeof(OneLinkList));
    initOneLinkList(stack);  // изначально стэк пуст

    // также нам понадобится массив посещённых вершин. Там единицей будем помечать посещённые вершины
    int* visited = (int*)calloc(nodes, sizeof(int));  // изначально массив обнулён

    // добавляем начальную вершину в стэк, отмечаем как посещённую и выводим на экран
    pushOneLinkStack(stack, start);
    visited[start] = 1;
    printf("%d ", start);

    int current_node = start;
    while (stack->size != 0)
    {
        current_node = popOneLinkStack(stack);
        for (int next_node = 0; next_node < nodes; ++next_node)
            // если есть путь в соседнюю вершину и она не посещалась
            if ((get2dInt(matrix, current_node, next_node) == 1) && !visited[next_node])
            {
                visited[next_node] = 1;
                printf("%d ", next_node);
                pushOneLinkStack(stack, next_node);
            }
    }
}

// создаёт случайный граф для заданного количества вершин и обходит его в глубину из нескольких вершин
void task1()
{
    printf("1. Обход графа в глубину при помощи стэка.\n\n");

    const int nodes = 10;
    int** graph = init2DArray(nodes, nodes);
    fill2DarrayRandom(graph, nodes, nodes, 2);
    printAdjMatrix(graph, nodes);

    printf("Пути обхода графа из нескольких вершин:\n");
    depthTravers(graph, nodes, 0);
    printf("\n");
    depthTravers(graph, nodes, 3);
    printf("\n");
    depthTravers(graph, nodes, 4);

    printf("\n\n");
}

///////////////////// ЗАДАНИЕ 2

// создаёт матрицу смежности для простого графа (без кратных рёбер и петель)
int** initSimpleGraph(const int nodes)
{
    int** array = (int**)calloc(nodes, sizeof(int*));
    for (int i = 0; i < nodes; ++i)
        *(array + i) = (int*)calloc(nodes, sizeof(int*));
    
    for (int i = 0; i < nodes; ++i)
        for (int j = 0; j < nodes; ++j)
        {
            if (i < j)
                set2dInt(array, i, j, rand() % 2);
            else if (i > j)
                set2dInt(array, i, j, get2dInt(array, j, i));
            // иначе (i == j) - петля, оставляем 0
        }
            
    return array;
}

void widthTraversRecursive(int** matrix, int* visited, const int size, int start, int* number_of_visited)
{
    if (!visited[start])
    {
        ++visited[start];
        ++(*number_of_visited);
        printf("%d ", start);
    }

    for (int next = 0; next < size; ++next)
    {
        if ((get2dInt(matrix, start, next) == 1) && !visited[next])
        {
            ++visited[next];
            printf("%d ", next);
            ++(*number_of_visited);
        }
        if (*number_of_visited < size)
            for (int adj = 0; adj < size; ++adj)
                if (adj != start && visited[adj])
                {
                    widthTraversRecursive(matrix, visited, size, start, number_of_visited);
                    if (*number_of_visited >= size)
                        return;
                }
    }
}

int* TraversByMatrix(int** matrix, const int size)
{
    int* visited = (int*)calloc(size, sizeof(int));  // изначально массив обнулён
    for (int i = 0; i < size; ++i)
        for (int j = 0; j < size; ++j)
            if (get2dInt(matrix, i, j) == 1)
                ++visited[j];
    return visited;
}

typedef struct
{
    int node;
    int edges;
} NodeEdges;

// сортирует массив сортировкой вставками
void sort_by_inserts(NodeEdges* array, int len)
{
    NodeEdges temp;
    int pos;
    for (int i = 1; i < len; ++i)
    {
        temp.node = array[i].node;
        temp.edges = array[i].edges;
        pos = i - 1;
        while (pos >= 0 && array[pos].edges < temp.edges)
        {
            array[pos + 1].node = array[pos].node;
            array[pos + 1].edges = array[pos].edges;
            pos--;
        }
        array[pos + 1].node = temp.node;
        array[pos + 1].edges = temp.edges;
    }
}

void printNodeEdge(NodeEdges* a)
{
    printf("вершина %d - %d рёбер\n", a->node, a->edges);
}

void printResult(NodeEdges* array, int len)
{
    for (int i = 0; i < len; ++i)
        printNodeEdge(array+i);
}

// создаёт случайный простой граф для заданного количества вершин и обходит его двумя способами с подсчётом количества ссылок на каждую вершину
void task2()
{
    printf("2. Обход простого графа рекурсивно.\n\n");

    const int nodes = 5;
    int** graph = initSimpleGraph(nodes);
    printAdjMatrix(graph, nodes);

    // также нам понадобится массив посещённых вершин. Там единицей будем помечать посещённые вершины
    int* visited = (int*)calloc(nodes, sizeof(int));  // изначально массив обнулён
    int number_of_visited = 0;
    printf("Путь из начальной вершины:\n");
    //widthTraversRecursive(graph, visited, nodes, 0, &number_of_visited);

    printf("\n\n");

    printf("3. Обход простого графа по матрице смежности.\n\n");
    int* edges = TraversByMatrix(graph, nodes);
    NodeEdges*  result2 = (NodeEdges*)calloc(nodes, sizeof(NodeEdges));
    for (int i = 0; i < nodes; ++i)
    {
        result2[i].node = i;
        result2[i].edges = edges[i];
    }
    sort_by_inserts(result2, nodes);
    printResult(result2, nodes);
    printf("\n\n");
}

int main()
{
    setlocale(LC_CTYPE, "rus");  // для кириллицы
    task1();
    task2();
    return 0;
}